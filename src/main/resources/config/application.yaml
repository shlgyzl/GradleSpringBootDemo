logging:
  level:
    org.springframework.data.mongodb.core: DEBUG
    com.application.repository: DEBUG
  config: classpath:config/log/logback-spring.xml
spring:
  servlet:
    multipart:
      #是否支持批量上传
      enabled: true
      #上传文件最大为 100M
      max-file-size: 100MB
      #上传总数据大小 200M
      max-request-size: 1024MB
  cloud:
    sentinel:
      transport:
        dashboard: http://47.105.46.4:8082
      log:
        dir: ./logs/alibaba-monitor
      eager: true
      enabled: true
  application:
    name: GradleSpringBoot
  boot:
    admin:
      client:
        url: http://47.105.46.4:8081
  quartz:
    jdbc:
      # fix it 初始化Quartz表结构,项目第一次启动配置程always,然后改成never 否则已生成的job会被初始化掉
      # 生产环境改成never
      initialize-schema: always
      #            initialize-schema: never
      # 这边是个坑，默认comment-prefix: --，但是org.quartz.impl.jdbcjobstore下面的mysql的sql脚本的注释前缀是#。
      # 所以在mysql环境下建表失败但是控制台并不报错。
      # fix it,set comment-prefix: -- when using oracle，set comment-prefix: --# when using sqlserver
      comment-prefix: '#'
    #设置quartz任务的数据持久化方式，默认是内存方式
    job-store-type: jdbc
    properties:
      org:
        quartz:
          scheduler:
            instanceName: GradleSpringBootScheduler
            instanceId: AUTO
          jobStore:
            class: org.quartz.impl.jdbcjobstore.JobStoreTX # 单机存储,非集群
            driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate
            tablePrefix: QRTZ_  #Quartz表前缀
            isClustered: true
            clusterCheckinInterval: 20000
            useProperties: false
            maxMisfiresToHandleAtATime: 1
          threadPool:
            class: org.quartz.simpl.SimpleThreadPool
            threadCount: 2
            threadPriority: 5
            threadsInheritContextClassLoaderOfInitializingThread: true
management:
  endpoints:
    enabled-by-default: true
    jmx:
      exposure:
        include: '*'
    web:
      exposure:
        include: '*'
      cors:
        allowed-methods: '*'
  endpoint:
    health:
      show-details: always

application: #第三方系统登录
  remoteDam:
    username: test_zuosl
    password: zuo123456
    apiBaseUrl: http://v3.dam.com.cn/

jhipster:
  cors:
    allowed-origins: "*"
    allowed-methods: "*"
    allowed-headers: "*"
    exposed-headers: "Authorization,Link,X-Total-Count"
    allow-credentials: true
    max-age: 1800
  async:
    core-pool-size: 2
    max-pool-size: 50
    queue-capacity: 10000
  security:
    remember-me:
      key: 4e431fe0f41cec2457ba464d1fa53d2e287a54e5e92c9dca30c68d95af40e1bbc2cc4d3d25f0f61049dc3934466e6586a8eb
    authentication:
      jwt:
        base64-secret: RFE2Y1NNTlRsRDNDLzJiblVQRnZMYUZ4WXVjV1huWWVYa1luY0NNT3hlTVU1QmI2ZVZ3N2pkVFBISjBHS08zSEV1NWNYMGVGSXh0S3ZTQURjSkdzWWJsRE5sTjg3cVpjdDUwSkxhQnR6WXlhOUdTNHc5YjBkazlmbnk1WXd4MFowT3hZYnZFUUU2dVVyWW1ET0IwbUtNeGNCbmlCc1dYOTFqSnhmNy9VTlc4JTNE
        token-validity-in-seconds: 86400
        token-validity-in-seconds-for-remember-me: 2592000
  cache: # ehcache使用
    ehcache:
      max-entries: 10000
      time-to-live-seconds: 3600
jetcache: #开启阿里巴巴封装的jetCache缓存框架
  statIntervalMinutes: 15
  areaInCacheName: false
  hiddenPackages: true
  local:
    default:
      type: linkedhashmap
      keyConvertor: fastjson
      limit: 100
      defaultExpireInMillis: 20000    #全局缓存失效时间
  remote:
    default:
      type: redis
      keyConvertor: fastjson
      valueEncoder: java
      valueDecoder: java
      poolConfig:
        minIdle: 5
        maxIdle: 20
        maxTotal: 50
      host: 47.105.46.4
      port: 6379
      password: 123456
      defaultExpireInMillis: 20000    #全局缓存失效时间      